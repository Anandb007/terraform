1.Importing Existing Resources
When?
      If infrastructure exists outside Terraform and you want Terraform to manage it.
How?
      Write a resource block in .tf files.
Run:
      terraform import <resource_address> <resource_id>
Important
      After import, run terraform plan to detect config mismatches.
      Update .tf files accordingly to match reality.


2. Dealing with Drift and Manual Changes
What is Drift?
      When infrastructure changes happen outside Terraform (manual console edits, scripts, etc.).    
      Terraform state file becomes out-of-sync with reality.
Symptoms      
      Terraform doesn’t detect missing or changed resources in terraform plan.
      terraform apply might fail or ignore changes.
Common Scenarios & Solutions
      Scenario	Problem	Solution
      Resource manually deleted	    Terraform state still thinks it exists	    Run terraform apply to recreate or remove state entry manually (terraform state rm) and then apply
      Resource manually modified	  Terraform plan doesn’t detect changes	      Use terraform refresh or terraform plan with refresh to update state and review diffs
      Resource manually added	      Terraform unaware	                          Use terraform import to add resource to state


3. Terraform Commands for Advanced State Management
      Command	                           Purpose	                                              Example
        terraform state list	              List all resources tracked in state	                     terraform state list
        terraform state show <res>	        Show details of a specific resource	                     terraform state show aws_instance.my_ec2
        terraform state rm <res>	          Remove resource from state (don’t delete in infra)	     terraform state rm aws_instance.my_ec2
        terraform state mv <src> <dst>	    Move/rename resource in state	                           terraform state mv aws_instance.old aws_instance.new


4. Protecting Infrastructure from Accidental Changes
      Lifecycle Rule: prevent_destroy
      Terraform provides lifecycle rules to control how it handles resource changes. One of the most critical lifecycle rules is:
            lifecycle {
                prevent_destroy = true
                    }

Purpose:
        The prevent_destroy rule ensures that Terraform will not destroy a resource, even if the configuration or apply operation requires it.
        This is especially useful to protect critical infrastructure from accidental deletion.

Lifecycle Rules:
        Prevent accidental destruction:
        resource "aws_instance" "example" {
          # ...
          lifecycle {
            prevent_destroy = true
          }
        }

-----How to Remove a Resource with prevent_destroy-----
You must do one of the following:
✅ Option 1: Remove the prevent_destroy rule
        # Remove this block:
        lifecycle {
          prevent_destroy = true
        }     
Then run:
          terraform apply   

✅ Option 2: Comment out or delete the entire resource block
        
        Also removes it from state
        Terraform will detect that and plan to destroy it (if prevent_destroy is no longer present)
        This will make Terraform refuse to destroy the resource unless you override with -force.

5. Remote State and Collaboration:
Problem
        If multiple users run Terraform concurrently, local state files can get out of sync or corrupt.

Solution:
        Use remote state backends like:
        AWS S3 with DynamoDB locking
        Terraform Cloud/Enterprise
        Azure Blob Storage
        Google Cloud Storage
Remote state enables:
        State locking to avoid concurrent writes.
        Sharing state among team members.
        Better security.

6. Modules for Reusability and Maintainability:
What?
        Encapsulated Terraform configurations you can reuse.
Why?
        Avoid repetition.
        Maintain DRY (Don’t Repeat Yourself).
        Share common infrastructure patterns.

How?
        Create modules as directories with .tf files.

Call modules with:
        module "vpc" {
          source = "./modules/vpc"
          cidr   = "10.0.0.0/16"
        }


8. Common Issues in Terraform and How to Solve Them:
Issue	                                                  Cause	                                        Solution
Terraform not detecting manual deletions	                State not updated or synced	                     Run terraform apply or terraform state rm + apply
Import fails with resource not found	                    Resource doesn’t exist in cloud	                 Check resource ID; resource must exist to import
Conflicts or corruption in state	                        Multiple users running Terraform concurrently	   Use remote state with locking
Provider plugin errors	                                  Version incompatibilities	                       Pin provider versions in config
Plan shows unexpected changes	                            Manual changes or drift	                         Review changes, run terraform refresh
Terraform apply stuck or slow	                            Large state files or network issues	             Use targeted applies or split configurations


9. Advanced Tips:
        Use terraform refresh to update state with real infrastructure without applying changes.
        Use workspaces to manage multiple environments (dev, staging, prod) in one config.
        Version your Terraform and providers carefully.
        Test with terraform plan thoroughly before applying.
        Use output variables to expose important info.

Summary:
        Area	What to Know / Do
        Import existing resources	Write config + terraform import
        Detect and fix drift	terraform plan, terraform apply, or manual state changes
        Manage state	Use terraform state commands and remote state backends
        Prevent accidents	Use lifecycle rules
        Collaborate	Use remote state with locking
        Modularize	Use modules
        Troubleshoot	Common error fixes and commands


##############################################################################################################################
resource (e.g., EC2 instance) managed by Terraform is deleted manually, but you don't know which one was deleted.


Dealing with Drift and Manual Changes in Terraform
  🔧 Scenario: One EC2 Instance Deleted Manually (Unknown Which One)
  🧱 Terraform Resource Block (with Count):
          resource "aws_instance" "web" {
            count         = 4
            ami           = "ami-0c55b159cbfafe1f0"
            instance_type = "t2.micro"
          }


This creates 4 EC2 instances:
          aws_instance.web[0]
          aws_instance.web[1]
          aws_instance.web[2]
          aws_instance.web[3]


❌ Problem
      Someone deleted one instance (say web[2]) outside of Terraform (e.g., from AWS Console).  
      You don’t know which one was deleted.
      Running terraform plan or terraform apply may not detect the deletion immediately due to Terraform relying on state.

✅ Goal
      Identify which specific instance is missing (web[0], web[1], etc.).
      Remove it from Terraform state.
      Let Terraform recreate only the missing one.

🧭 Step-by-Step Detection & Recovery
🔍 Step 1: List All Instances in State
      terraform state list

You will see output like:
      aws_instance.web[0]
      aws_instance.web[1]
      aws_instance.web[2]
      aws_instance.web[3]
All 4 still exist in Terraform's state, even though one is deleted in AWS.

🔎 Step 2: Inspect Each Resource
Run:
      terraform state show aws_instance.web[0]
      terraform state show aws_instance.web[1]
      terraform state show aws_instance.web[2]
      terraform state show aws_instance.web[3]


Each command will try to read the actual infrastructure. For the one that was deleted, Terraform will return an error like:

      Error: InvalidInstanceID.NotFound: The instance ID 'i-0abc12345def6789' does not exist

This tells you which index (e.g., [2]) is the missing one.

🧹 Step 3: Remove Missing Resource from State
Once you’ve identified the missing index (say [2]), remove it from state:
      terraform state rm aws_instance.web[2]

🔁 Step 4: Reapply to Recreate the Instance
      terraform apply
Terraform now sees that it has a count = 4, but only 3 are present, so it will create one new instance to meet the count.


✅ Optional: Automate the Process with a Script

You can loop through the instances and detect which one is broken:

      for i in {0..3}; do
        echo "Checking aws_instance.web[$i]..."
        terraform state show aws_instance.web[$i] > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "Missing instance detected: aws_instance.web[$i]"
        fi
      done
Then remove the missing one and apply.

🧾 Summary
Task	                                              Command
List all instances in state	                        terraform state list
Inspect each instance	                              terraform state show aws_instance.web[i]
Detect missing one	                                Look for NotFound or error output
Remove from state	                                  terraform state rm aws_instance.web[i]
Recreate missing instance	                          terraform apply
